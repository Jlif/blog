---
title: JEP-425 Virtual Threads (Preview)
categories: 翻译
tags: [JEP, Java, 翻译, 协程]
abbrlink: 910d18dc
date: 2022-04-30
---

# JEP 425: Virtual Threads (Preview)

> 提示：本文翻译的时候，文档最新版本是 2022/06/08，所以本文可能存在一定的时效性问题，请读者注意。

## 总览
将*虚拟线程*引入到 Java 平台。虚拟线程是轻量级的线程，可以大大减少编写、维护和监测高吞吐量并发应用程序的工作量。这是 [预览 API](https://openjdk.java.net/jeps/12) .

## 目标
- 使以简单的线程每请求方式编写的服务器应用程序能够以接近最佳的硬件利用率进行扩展。
- 让使用 `java.lang.Thread` API 的现有代码能够以最小的改动采用虚拟线程。
- 使用现有的 JDK 工具轻松地对虚拟线程进行故障排除、调试和分析。

## 非目标
- 我们的目标不是移除线程的传统实现，也不是默默地将现有的应用程序迁移到使用虚拟线程。
- 它的目标不是改变 Java 的基本并发模型。
- 在 Java 语言或 Java 库中提供新的数据并行结构不是我们的目标。流 API 仍然是并行处理大型数据集的首选方式。

<!-- more -->

## 动机
近三十年来，Java 开发者一直依赖线程作为并发服务器应用程序的构建基础模块。每个方法中的每条语句都在一个线程中执行，由于 Java 是多线程的，所以多个执行线程同时发生。线程是 Java 的并发单元：一段顺序代码，与其他此类单元同时运行，而且基本上是独立的。每个线程都提供一个堆栈来存储局部变量和协调方法调用，以及出错时的上下文：异常是由同一线程中的方法抛出和捕获的，因此开发人员可以使用线程的堆栈跟踪来找出发生了什么。线程也是工具的一个核心概念：调试器通过线程方法中的语句，剖析器将多个线程的行为可视化，以帮助了解其性能。

### 线程每请求的风格
服务器应用程序通常处理相互独立的并发用户请求，因此，应用程序通过在整个请求期间为该请求分配一个线程来处理请求是合理的。这种线程每请求的风格容易理解，容易编程，也容易调试和分析，因为它使用操作系统平台的最小并发单元来代表应用程序的并发单元。

服务器应用程序的可扩展性受 Little 定律的制约，该定律将延迟、并发性和吞吐量联系起来。对于一个给定的请求处理时间（即延迟），应用程序同时处理的请求数量（即并发性）必须与到达率（即吞吐量）成比例增长。例如，假设一个平均延迟为 50ms 的应用程序，通过并发处理 10 个请求，达到每秒 200 个请求的吞吐量。为了使该应用程序扩展到每秒 2000 个请求的吞吐量，它将需要同时处理 100 个请求。如果每个请求都在一个线程中处理，那么，为了使应用程序跟上，线程的数量必须随着吞吐量的增长而增长。

不幸的是，可用的线程数量是有限的，因为 JDK 将线程作为操作系统线程的封装来实现。操作系统线程的调度成本很高，所以我们不能有太多的线程，这使得该实现不适合线程每请求的方式。如果每个请求在其持续时间内消耗一个线程，也就是一个操作系统线程，那么线程的数量往往在其他资源（如 CPU 或网络连接）耗尽之前就已经成为限制因素了。JDK 目前对线程的实现将应用程序的吞吐量限制在一个远远低于硬件所能支持的水平。即使线程是池化的，这种情况也会发生，因为池化有助于避免启动新线程的高成本，但不会增加线程的总数。

### 用异步风格提高可扩展性
一些希望最大限度地利用硬件的开发者已经放弃了线程每请求风格，而选择了线程共享风格。请求处理代码不是从头到尾在一个线程上处理一个请求，而是在等待一个 I/O 操作完成时将其线程返回到一个池中，以便该线程可以为其他请求提供服务。这种细粒度的线程共享，即代码只在执行计算时保留线程，而不是在等待 I/O 时保留线程，允许大量的并发操作而不消耗大量的线程。虽然它消除了操作系统线程稀缺性对吞吐量的限制，但它的代价很高。它需要所谓的异步编程风格，采用一套独立的 I/O 方法，不等待 I/O 操作的完成，而是在以后向回调发出完成信号。如果没有专门的线程，开发者必须将他们的请求处理逻辑分解成小的阶段，通常写成 lambda 表达式，然后用 API 将它们组成一个顺序管道（例如 CompletableFuture，或所谓的"响应式"框架）。因此，他们放弃了语言的基本顺序组合操作符，如循环和 try/catch 块。

在异步风格中，一个请求的每个阶段可能在不同的线程上执行，每个线程以交错的方式运行属于不同请求的阶段。这对理解程序行为有深刻的影响。堆栈跟踪没有提供可用的上下文，调试器不能穿过请求处理逻辑，剖析器不能将一个操作的成本与它的调用者联系起来。当使用 Java 的流 API 来处理短管道中的数据时，组成 lambda 表达式是可以管理的，但当应用程序中所有的请求处理代码都必须以这种方式编写时，就会出现问题。这种编程风格与 Java 平台不一致，因为应用程序的并发单元，即异步流水线，不再是平台的并发单位了。

### 使用虚拟线程保留线程线程每请求每请求的风格
为了使应用程序能够扩展，同时与平台保持和谐，我们应该努力通过更有效地实现线程来保留线程每请求的风格，这样它们就会更多。操作系统无法更有效地实现操作系统线程，因为不同的语言和运行时以不同的方式使用线程栈。然而，Java 运行时有可能以一种切断与操作系统线程的一对一对应关系的方式来实现 Java 线程。就像操作系统通过将大量的虚拟地址空间映射到有限的物理 RAM 上，给人以内存充足的错觉一样，Java 运行时也可以通过将大量的虚拟线程映射到少量的操作系统线程上，给人以线程充足的错觉。

虚拟线程是 `java.lang.Thread` 的一个实例，它不与特定的操作系统线程相联系。相比之下，平台线程是以传统方式实现的 `java.lang.Thread` 的一个实例，作为操作系统线程的一个封装。

线程每请求风格的应用程序代码可以在请求的整个过程中在虚拟线程中运行，但虚拟线程只在 CPU 上执行计算时消耗一个操作系统线程。其结果是与异步风格相同的可扩展性，只是它是以透明方式实现的。当在虚拟线程中运行的代码调用 java.* API 中的阻塞 I/O 操作时，运行时会执行一个非阻塞的操作系统调用，并自动暂停虚拟线程，直到以后可以恢复。对 Java 开发者来说，虚拟线程只是创建成本低且几乎无限多的线程。硬件利用率接近最佳，允许高水平的并发，因此，具有很高的吞吐量，与此同时应用程序仍然与 Java 平台的多线程设计及其工具相协调。

### 虚拟线程的影响
虚拟线程开销低，数量众多，因此没必要池化使用：每个任务都应创建一个新的虚拟线程。因此，大多数虚拟线程都是短命的，而且调用栈很浅，只执行一次 HTTP 客户端调用或一次 JDBC 查询。相比之下，操作系统线程是重量级和昂贵的，因此往往必须是池化的。它们往往寿命很长，有很深的调用栈，并在许多任务之间共享使用。

总之，虚拟线程保留了与 Java 平台设计相协调的可靠的线程每请求风格，同时优化了硬件的利用。使用虚拟线程不需要学习新的概念，尽管它可能需要忘掉为应对今天的高线程成本而养成的习惯。虚拟线程不仅能帮助应用开发者，还能帮助框架设计者提供易于使用的 API，这些 API 与平台的设计兼容，同时又不影响扩展性。

## 描述
今天，JDK 中 java.lang.Thread 的每个实例都是一个平台线程。平台线程在底层操作系统线程上运行 Java 代码，并在代码的整个生命周期内占用操作系统线程。平台线程的数量受限于操作系统线程的数量。

虚拟线程是 java.lang.Thread 的一个实例，它在底层操作系统线程上运行 Java 代码，但在代码的整个生命周期中不占用操作系统线程。这意味着许多虚拟线程可以在同一个操作系统线程上运行他们的 Java 代码，有效地共享它。虽然一个平台线程垄断了宝贵的操作系统线程，但虚拟线程却没有。虚拟线程的数量可以比操作系统线程的数量大得多。

虚拟线程是一种轻量级的线程实现，由 JDK 而不是操作系统提供。它们是用户模式线程的一种形式，在其他多线程语言中也很成功（例如 Go 中的 goroutines 和 Erlang 中的 process）。用户模式线程甚至在 Java 的早期版本中作为所谓的"绿色线程"出现，当时操作系统线程还没有成熟和普及。然而，Java 的绿色线程都共享一个操作系统线程（M:1 调度），并最终被作为操作系统线程的封装器（1:1 调度）的平台线程所超越。虚拟线程采用 M: N 调度，即大量（M）虚拟线程被调度到较少数量（N）的操作系统线程上运行。

### 使用虚拟线程 VS 使用平台线程
开发人员可以选择到底是使用虚拟线程还是平台线程。下面是一个创建大量虚拟线程的示例程序。该程序首先获得一个 ExecutorService，它将为每个提交的任务创建一个新的虚拟线程。然后，它提交了 10,000 个任务，并等待它们全部完成：
```Java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(Duration.ofSeconds(1));
            return i;
        });
    });
}  // executor.close() is called implicitly, and waits
```
这段示例代码里面的任务十分简单，就是休眠一秒，现在的硬件轻松能支持一万个虚拟线程并发执行这样的代码。然而在底层，JDK 仅在少量的操作系统线程上运行代码，也许就一个。

如果这个程序使用 ExecutorService，为每个任务创建一个新的平台线程，例如 `Executors.newCachedThreadPool()`，情况就会大不相同。ExecutorService 将试图创建 10,000 个平台线程，这会导致创建 10,000 个操作系统线程，而程序可能会崩溃，这取决于机器和操作系统。

如果程序使用 ExecutorService，从一个线程池中获取平台线程，例如 `Executors.newFixedThreadPool(200)`，情况也不并不会好多少。ExecutorService 将创建 200 个平台线程，由所有 10,000 个任务共享，因此许多任务将按顺序运行，而不是并发运行，程序将需要很长时间才能完成。对于这个程序，有 200 个平台线程的池子只能达到每秒 200 个任务的吞吐量，而虚拟线程的吞吐量约为每秒 10000 个任务（经过充分预热）。此外，如果将示例程序中的 10_000 改为 1_000_000，那么该程序将提交 1,000,000 个任务，创建 1,000,000 个并发运行的虚拟线程，并（在充分预热后）实现大约 1,000,000 个任务/秒的吞吐量。

如果这个程序中的任务是进行一秒钟的计算（例如，对一个巨大的数组进行排序），而不仅仅是休眠，那么增加超过处理器内核的线程数量将没有帮助，无论它们是虚拟线程还是平台线程。虚拟线程不是更快的线程 - 它们运行代码的速度并不比平台线程快。它们的存在是为了提供规模（更高的吞吐量），而不是速度（更低的延时）。它们可以比平台线程多得多，所以根据 [利特尔法则](https://zh.wikipedia.org/zh/%E5%88%A9%E7%89%B9%E7%88%BE%E6%B3%95%E5%89%87) ，它们可以实现更高的并发，从而获得更高的吞吐量。

换句话说，在以下情况，虚拟线程可以显著提高应用程序的吞吐量
- 并发任务的数量很高（超过几千），并且
- 工作负载不受 CPU 限制，因为在这种情况下，拥有比处理器内核更多的线程不能提高吞吐量。

虚拟线程有助于提高典型的服务器应用程序的吞吐量，正是因为这种应用程序由大量的并发任务组成，它们的大部分时间都在等待。

> 译者注：上面这些一句话说就是虚拟线程对于 CPU 密集型任务吞吐量的改善不明显，主要是显著提升 IO 密集型并发任务的吞吐量。

一个虚拟线程可以运行任何平台线程可以运行的代码。特别是，虚拟线程支持线程局部变量和线程中断，就像平台线程一样。这意味着，现有的处理请求的 Java 代码将很容易在虚拟线程中运行。许多服务器框架会选择自动完成这一工作，为每个传入的请求启动一个新的虚拟线程，并在其中运行应用程序的业务逻辑。

下面是一个服务器应用程序的例子，它聚合了另外两个服务的结果。一个假设的服务器框架（不具体指哪个）为每个请求创建一个新的虚拟线程，并在该虚拟线程中运行应用程序的处理代码。而应用程序代码又创建了两个新的虚拟线程，通过与第一个例子相同的 ExecutorService 并发地获取资源。

```Java
void handle(Request request, Response response) {
    var url1 = ...
    var url2 = ...
 
    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
        var future1 = executor.submit(() -> fetchURL(url1));
        var future2 = executor.submit(() -> fetchURL(url2));
        response.send(future1.get() + future2.get());
    } catch (ExecutionException | InterruptedException e) {
        response.fail(e);
    }
}
 
String fetchURL(URL url) throws IOException {
    try (var in = url.openStream()) {
        return new String(in.readAllBytes(), StandardCharsets.UTF_8);
    }
}
```

上述服务器应用程序的例子里，即使包含了直接的阻塞代码，也很容易扩展，因为它调用的是大量的虚拟线程。

`Executor.newVirtualThreadPerTaskExecutor()` 不是创建虚拟线程的唯一方法。下面讨论的新的 `java.lang.Thread.Builder` API，可以创建和启动虚拟线程。此外， [Structured Concurrency](https://openjdk.java.net/jeps/428) 提供了一个更强大的API来创建和管理虚拟线程，特别是在类似于这个服务器例子的代码中，线程之间的关系对于平台和工具来说是透明的。

### 虚拟线程是预览特性，默认处于禁用状态
上面的程序使用了 `Executors.newVirtualThreadPerTaskExecutor()` 方法，所以要在 JDK 19 上运行它们，你必须按以下方法启用预览 API：
- 用 `javac --release 19 --enable-preview Main.java` 编译程序，用 `java --enable-preview Main` 运行程序
- 当使用源代码启动器时，用 `java --source 19 --enable-preview Main.java` 运行该程序
- 当使用 jshell 时，用 `jshell --enable-preview` 启动它

### 不要池化虚拟线程
开发人员通常会将应用程序代码从传统的基于线程池的 `ExecutorService` 迁移到虚拟线程每任务的 `ExecutorService`。线程池，就像所有的资源池一样，是为了共享昂贵的资源，但虚拟线程并不昂贵，而且从来没有必要把它们放在一起。

开发人员有时会使用线程池来限制对有限资源的并发访问。例如，如果一个服务不能处理超过 20 个并发请求，那么通过提交给一个容量为 20 的线程池来执行对该服务的所有访问将确保这一点。由于平台线程的高成本使得线程池无处不在，这个模式也变得无处不在，但开发者不应该为了限制并发而特地虚拟线程池。应该使用专门为此目的而设计的结构，如 `semaphores`，来保护对有限资源的访问。这比线程池更有效、更方便，也更安全，因为不存在线程本地数据意外地从一个任务泄漏到另一个任务的风险。

### 观测虚拟线程
编写清晰的代码并不是全部的内容。对运行中的程序状态的清晰呈现对于故障诊断、维护和优化也是至关重要的，JDK 早已提供了调试、剖析和监控线程的机制。这些工具也应该为虚拟线程做同样的事情（也许要对它们的数量做一些调整），因为它们毕竟是 java.lang.Thread 的实例。

Java 调试器可以穿过虚拟线程，显示调用堆栈，并检查堆栈框架中的变量。JDK Flight Recorder（JFR）是 JDK 的低开销剖析和监控机制，它可以将应用程序代码的事件（如对象分配和 I/O 操作）与正确的虚拟线程联系起来。对于以异步风格编写的应用程序，这些工具则无能为力。在那种风格中，任务与线程之间没有联系，所以调试器不能显示或操作任务的状态，剖析器也不能知道一个任务花了多少时间来等待 I/O。

线程转储是另一个流行的工具，用于排除以线程每请求风格编写的应用程序的故障。不幸的是，JDK 的传统线程转储，即用 `jstack` 或 `jcmd` 获得的线程转储，呈现的是一个平面的线程列表。这适合于几十或几百个平台线程，但不适合于几千或几百万个虚拟线程。因此，我们不会将传统的线程转储扩展到包括虚拟线程，而是在 `jcmd` 中引入一种新的线程转储，将虚拟线程与平台线程放在一起，并以一种有意义的方式进行分组。当程序使用 [Structured Concurrency](https://openjdk.java.net/jeps/428) 时，可以显示线程之间更丰富的关系。

因为可视化和分析大量的线程可以从工具化中受益，所以 `jcmd` 除了纯文本外，还可以以 JSON 格式发起新的线程转储。

```bash
$ jcmd <pid> Thread.dump_to_file -format=json <file>
```

新的线程转储格式列出了在网络 I/O 操作中被阻塞的虚拟线程，以及由上面显示的 new-thread-per-task `ExecutorService` 创建的虚拟线程。它不包括对象地址、锁、JNI 统计、堆统计，以及其他出现在传统线程转储中的信息。此外，由于它可能需要列出大量的线程，生成一个新的线程转储并不会暂停应用程序。

下面是这样一个线程转储的例子，它取自一个与上面第二个例子类似的应用程序，在 JSON 浏览器中呈现（点击放大）:
![json 格式的线程转储](https://img.jiangchen.tech/202206121646348.png)
由于虚拟线程是在 JDK 中实现的，并不与任何特定的操作系统线程相联系，因此它们对操作系统来说是不可见的，而操作系统也不知道它们的存在。操作系统级别的监控将观察到 JDK 进程使用的操作系统线程比虚拟线程的数量少。

### 虚拟线程的调度
为了进行有用的工作，线程需要被调度，也就是说，被分配到一个处理器核心上执行。对于作为操作系统线程实现的平台线程，JDK 依赖于操作系统的调度器。相比之下，对于虚拟线程，JDK 有自己的调度器。JDK 的调度器不是直接将虚拟线程分配给处理器，而是将虚拟线程分配给平台线程（这就是前面提到的虚拟线程的 M：N 调度）。然后，平台线程由操作系统照常调度。

JDK 的虚拟线程调度器是一个基于工作窃取算法的 `ForkJoinPool`，以 FIFO 模式运行。调度器的并行性是指可用于调度虚拟线程的平台线程的数量。默认情况下，它等于可用处理器的数量，但它可以通过系统属性 `jdk.virtualThreadScheduler.parallelism` 来调整。请注意，这个 `ForkJoinPool` 与普通池不同，后者用于实现并行流，并且以后进先出的模式运行。

调度器分配给一个虚拟线程的平台线程被称为虚拟线程的载体。一个虚拟线程在其生命周期中可以被调度在不同的载体上；换句话说，调度器并不在虚拟线程和任何特定的平台线程之间保持亲和力。从 Java 代码的角度来看，一个正在运行的虚拟线程在逻辑上是独立于其当前载体的。

载体的身份对虚拟线程来说是不可用的。Thread.currentThread()返回的值始终是虚拟线程本身。

载体和虚拟线程的堆栈痕迹是分开的。在虚拟线程中抛出的异常将不包括载体的堆栈帧。线程转储不会在虚拟线程的堆栈中显示载体的堆栈帧，反之亦然。

载体的线程本地变量对于虚拟线程来说是不可用的，反之亦然。

此外，从 Java 代码的角度来看，一个虚拟线程和它的载体暂时共享一个操作系统线程的事实是看不见的。相比之下，从本地代码的角度来看，虚拟线程和其载体都运行在同一个本地线程上。因此，在同一个虚拟线程上被多次调用的本地代码在每次调用时可能会观察到不同的操作系统线程标识符。

目前，调度器并没有为虚拟线程实现时间共享。时间共享是对已经消耗了一定数量的 CPU 时间的线程的强制抢占。虽然当平台线程数量相对较少且 CPU 利用率为 100% 时，时间共享可以有效地减少一些任务的延迟，但不清楚时间共享在一百万个虚拟线程中是否会同样有效。

### 虚拟线程的运行
为了利用虚拟线程的优势，没有必要重写你的程序。虚拟线程不要求或期望应用程序代码明确地将控制权交还给调度器；换言之，虚拟线程不是合作性的。用户代码不能对虚拟线程如何或何时分配给平台线程做出假设，就像它对平台线程如何或何时分配给处理器内核做出假设一样。

为了在虚拟线程中运行代码，JDK 的虚拟线程调度器通过将虚拟线程安装在平台线程上，将虚拟线程分配到平台线程上执行。这使得平台线程成为虚拟线程的载体。之后，在运行一些代码后，虚拟线程可以从其载体上卸载。这时，平台线程是自由的，所以调度器可以在其上挂载一个不同的虚拟线程，从而使其再次成为载体。

通常情况下，当一个虚拟线程在 I/O 或 JDK 中的一些其他阻塞操作（如 BlockingQueue.take()）上阻塞时，它就会解挂。当阻塞操作准备完成时（例如，在套接字上已经收到了字节），它将虚拟线程提交回调度器，调度器将把虚拟线程挂载到载体上以继续执行。

虚拟线程的挂载和卸载频繁而透明地发生，并且不会阻塞任何操作系统线程。例如，前面显示的服务器应用程序包括以下一行代码，它包含对阻塞操作的调用。
```Java
response.send(future1.get() + future2.get());
```
这些操作将导致虚拟线程多次挂载和卸载，一般来说，每次调用 get()都会有一次，在 send(...)中执行 I/O 的过程中可能会有多次。

JDK 中的绝大多数阻塞操作都会解除对虚拟线程的挂载，从而释放其载体和底层操作系统线程，以承担新的工作。然而，JDK 中的一些阻塞操作并没有解除对虚拟线程的挂载，因此会阻塞其载体和底层 OS 线程。这是因为操作系统层面（如许多文件系统操作）或 JDK 层面（如 Object.wait()）的限制。这些阻塞操作的实现将通过暂时扩大调度器的并行性来补偿对操作系统线程的捕获。因此，调度器的 ForkJoinPool 中的平台线程数量可能会暂时超过可用处理器的数量。调度器可用的最大平台线程数可以通过系统属性 jdk.virtualThreadScheduler.maxPoolSize 来调整。

有两种情况下，虚拟线程在阻塞操作中不能被卸载，因为它被钉在了载体上。
- 当它在一个同步块或方法中执行代码时
- 当它执行一个本地方法或一个外来函数时。

自旋并不会使应用程序变得不正确，但它可能会阻碍其可扩展性。如果一个虚拟线程在被钉住时执行了一个阻塞操作，如 I/O 或 BlockingQueue.take()，那么它的载体和底层操作系统线程在操作的过程中就会被阻塞。频繁的长时间钉住会因为捕获载体而损害应用程序的可扩展性。

调度器不会通过扩展其并行性来补偿钉住的情况。相反，通过修改频繁运行的同步块或方法，避免频繁和长时间的钉住，并守护潜在的长 I/O 操作，以使用 java.util.concurrent.locks.ReentrantLock 代替。没有必要替换那些不经常使用（例如，只在启动时执行）或守护内存操作的同步块和方法。一如既往，努力保持锁策略的简单和清晰。

新的诊断方法有助于将代码迁移到虚拟线程，以及评估是否应该用 java.util.concurrent 锁取代 synchronized 的特定使用：
- 当一个线程在钉住时阻塞时，会发出一个 JDK 飞行记录器（JFR）事件（见 JDK 飞行记录器）。
- 系统属性 jdk.tracePinnedThreads 会在线程在被钉住时阻塞时触发堆栈跟踪。使用 -Djdk.tracePinnedThreads=full 运行时，当一个线程在钉住时阻塞时，会打印出完整的堆栈跟踪，并突出显示本地帧和持有监视器的帧。使用 -Djdk.tracePinnedThreads=short 运行时，输出的结果只限于有问题的帧。

在未来的版本中，我们可能会去掉上面的第一个限制（在同步中钉住）。第二个限制是为了与本地代码正确互动。

### 内存占用以及对垃圾回收的影响
虚拟线程的堆栈作为堆栈块对象存储在 Java 的垃圾收集堆中。堆栈随着应用程序的运行而增长和缩小，这既是为了提高内存效率，也是为了适应任意深度的堆栈（最多到 JVM 配置的平台线程堆栈大小）。这种效率使大量的虚拟线程成为可能，从而使服务器应用程序中的每请求线程风格继续保持活力。

在上面的第二个例子中，回顾一下，一个假设的框架通过创建一个新的虚拟线程并调用 handle 方法来处理每个请求；即使它在深层调用堆栈的末端调用 handle（在认证、事务等之后），handle 本身也会产生多个虚拟线程，这些虚拟线程只执行短暂的任务。因此，对于每个具有深层调用堆栈的虚拟线程来说，会有多个具有浅层调用堆栈的虚拟线程，消耗的内存很少。

一般来说，虚拟线程所需的堆空间和垃圾收集器活动的数量很难与异步代码相比。一百万个虚拟线程至少需要一百万个对象，但一百万个任务共享一个平台线程池也是如此。此外，处理请求的应用程序代码通常在 I/O 操作中保持数据。每线程请求代码可以将这些数据保存在本地变量中，这些变量存储在堆中的虚拟线程栈中，而异步代码必须将相同的数据保存在堆对象中，这些对象从流水线的一个阶段传递到下一个阶段。一方面，虚拟线程所需的堆栈框架布局比紧凑对象的布局更浪费；另一方面，虚拟线程可以在许多情况下突变和重用它们的堆栈（取决于低级别的 GC 交互），而异步管道总是需要分配新对象，因此虚拟线程可能需要较少的分配。总的来说，每请求线程与异步代码的堆消耗和垃圾收集器活动应该是大致相似的。随着时间的推移，我们希望能使虚拟线程栈的内部表示明显更紧凑。

与平台线程栈不同，虚拟线程栈不是 GC 根，因此其中包含的引用不会被执行并发堆扫描的垃圾收集器（如 G1）在停止-世界暂停中遍历。这也意味着，如果一个虚拟线程在例如 BlockingQueue.take()上被阻塞，并且没有其他线程可以获得对该虚拟线程或队列的引用，那么该线程就可以被垃圾收集--这很好，因为该虚拟线程永远不能被中断或解除阻塞。当然，如果虚拟线程正在运行，或者它被阻塞，并且可能被解除阻塞，那么它将不会被垃圾收集。

目前虚拟线程的一个限制是，G1 GC 不支持巨大的堆栈块对象。如果一个虚拟线程的堆栈达到区域大小的一半，可能小到 512KB，那么可能会抛出一个 StackOverflowError。

### 变更细节
剩下的几个小节详细描述了我们提出的整个 Java 平台及其实现的变化：
- [JEP 425: Virtual Threads (Preview)](#jep-425-virtual-threads-preview)
  - [总览](#总览)
  - [目标](#目标)
  - [非目标](#非目标)
  - [动机](#动机)
    - [线程每请求的风格](#线程每请求的风格)
    - [用异步风格提高可扩展性](#用异步风格提高可扩展性)
    - [使用虚拟线程保留线程线程每请求每请求的风格](#使用虚拟线程保留线程线程每请求每请求的风格)
    - [虚拟线程的影响](#虚拟线程的影响)
  - [描述](#描述)
    - [使用虚拟线程 VS 使用平台线程](#使用虚拟线程-vs-使用平台线程)
    - [虚拟线程是预览特性，默认处于禁用状态](#虚拟线程是预览特性默认处于禁用状态)
    - [不要池化虚拟线程](#不要池化虚拟线程)
    - [观测虚拟线程](#观测虚拟线程)
    - [虚拟线程的调度](#虚拟线程的调度)
    - [虚拟线程的运行](#虚拟线程的运行)
    - [内存占用以及对垃圾回收的影响](#内存占用以及对垃圾回收的影响)
    - [变更细节](#变更细节)
      - [java.lang.Thread](#javalangthread)
      - [Thread-local variables](#thread-local-variables)
      - [java.util.concurrent](#javautilconcurrent)
      - [Networking](#networking)
      - [java.io](#javaio)
      - [Java Native Interface (JNI)](#java-native-interface-jni)
      - [Debugging (JVM TI, JDWP, and JDI)](#debugging-jvm-ti-jdwp-and-jdi)
      - [JDK Flight Recorder (JFR)](#jdk-flight-recorder-jfr)
      - [Java Management Extensions (JMX](#java-management-extensions-jmx)
      - [java.lang.ThreadGroup](#javalangthreadgroup)
  - [备选方案](#备选方案)
  - [测试](#测试)
  - [风险和假设](#风险和假设)
  - [依赖](#依赖)
  - [参考文档：](#参考文档)

#### java.lang.Thread

#### Thread-local variables

#### java.util.concurrent

#### Networking

#### java.io

#### Java Native Interface (JNI)

#### Debugging (JVM TI, JDWP, and JDI)

#### JDK Flight Recorder (JFR)

#### Java Management Extensions (JMX

#### java.lang.ThreadGroup

## 备选方案

## 测试

## 风险和假设

## 依赖
- [JEP 416 (Reimplement Core Reflection with Method Handles)](https://openjdk.java.net/jeps/416) in JDK 18 removed the VM-native reflection implementation. This allows virtual threads to park gracefully when methods are invoked reflectively.
- [JEP 353 (Reimplement the Legacy Socket API)](https://openjdk.java.net/jeps/353) in JDK 13, and [JEP 373 (Reimplement the Legacy DatagramSocket API)](https://openjdk.java.net/jeps/373) in JDK 15, replaced the implementations of java.net.Socket, ServerSocket, and DatagramSocket with new implementations designed for use with virtual threads.
- [JEP 418 (Internet-Address Resolution SPI)](https://openjdk.java.net/jeps/418) in JDK 18 defined a service-provider interface for host name and address lookup. This will allow third-party libraries to implement alternative java.net.InetAddress resolvers that do not pin threads during host lookup.

## 参考文档：
 [JEP 425: Virtual Threads (Preview)](https://openjdk.java.net/jeps/425)

